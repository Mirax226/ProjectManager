const crypto = require('crypto');

function shortHash(input) {
  return crypto.createHash('sha1').update(String(input || '')).digest('hex').slice(0, 8);
}

function createRefId(prefix = 'GH') {
  return `${prefix}-${Date.now().toString(36).toUpperCase()}-${crypto.randomBytes(2).toString('hex').toUpperCase()}`;
}

async function createAutoPrForSuggestion(input = {}) {
  const {
    project,
    suggestion,
    actor,
    hasAccess,
    timeline,
    github,
    mode = 'pr',
    shadowConfirmed = false,
  } = input;

  if (!hasAccess) throw new Error('github_access_denied');
  if (!shadowConfirmed) throw new Error('shadow_run_required');
  if (!project?.repoSlug) throw new Error('repo_required');
  if (!suggestion?.ruleId) throw new Error('suggestion_required');
  if (!Array.isArray(suggestion.patchOperations) || !suggestion.patchOperations.length) throw new Error('patch_operations_required');

  const refId = createRefId('GH');
  const branch = `pm/fix/${suggestion.ruleId.toLowerCase()}-${shortHash(refId)}`;
  const baseBranch = suggestion.baseBranch || project.defaultBranch || 'main';

  await github.createBranch(project.repoSlug, branch, baseBranch);
  const applyResult = await github.applyPatchPlan(project.repoSlug, branch, suggestion.patchOperations);

  if (!applyResult?.ok) {
    timeline?.append({
      scope: 'project',
      projectId: project.id,
      type: 'github.auto_pr_failed',
      severity: 'error',
      title: `Auto PR failed for ${suggestion.title || suggestion.ruleId}`,
      detailsMasked: `mode=${mode}; reason=${applyResult?.error || 'patch_failed'}`,
      refId,
      tags: ['github', 'auto-pr', 'failed'],
    });
    throw new Error(applyResult?.error || 'patch_apply_failed');
  }

  const commitMessage = `PM: Fix ${suggestion.title || suggestion.ruleId}`;
  const commit = await github.commit(project.repoSlug, branch, commitMessage, {
    authorName: 'PM Bot',
    authorEmail: 'pm-bot@local',
  });

  if (mode === 'commit') {
    timeline?.append({
      scope: 'project',
      projectId: project.id,
      type: 'github.direct_commit',
      severity: 'warn',
      title: `Direct commit created for ${suggestion.title || suggestion.ruleId}`,
      detailsMasked: `branch=${branch}; sha=${commit.sha}`,
      refId,
      tags: ['github', 'direct-commit'],
    });
    return { refId, mode, branch, commitSha: commit.sha };
  }

  const pr = await github.createPullRequest(project.repoSlug, {
    title: `PM: Fix ${suggestion.title || suggestion.ruleId}`,
    head: branch,
    base: baseBranch,
    body: [
      '## Diagnosis',
      suggestion.problemSummary || suggestion.title || suggestion.ruleId,
      '',
      '## Fix summary',
      suggestion.fixSummary || 'Automated patch generated by PM.',
      '',
      `refId: ${refId}`,
      `generatedBy: PM (actor:${actor || 'unknown'})`,
    ].join('\n'),
  });

  timeline?.append({
    scope: 'project',
    projectId: project.id,
    type: 'github.auto_pr_created',
    severity: 'info',
    title: `Auto PR created for ${suggestion.title || suggestion.ruleId}`,
    detailsMasked: `branch=${branch}; pr=${pr.url}; files=${applyResult.filesChanged || 0}`,
    refId,
    tags: ['github', 'auto-pr'],
  });

  return {
    refId,
    mode: 'pr',
    branch,
    commitSha: commit.sha,
    prNumber: pr.number,
    prUrl: pr.url,
  };
}

module.exports = { createAutoPrForSuggestion };
